---
title: Homework3
date: 2025-10-18 00:10:00 
categories: [TOP_CATEGORY, SUB_CATEGORY]
tags: [homework]     # TAG names should always be lowercase
css: /assets/css/prova.css
math: true
---
<link rel="stylesheet" href="{{ '/assets/css/prova.css'}}">

# RSA encoding

The **RSA**  (Rivest-Shamir-Adleman) cryptosystem is a family of public key cryptosystems, one of the oldest widely used for secure data transmission.
The initialism "RSA" comes from the surnames of [Ron Rivest](https://en.wikipedia.org/wiki/Ron_Rivest "Ron Rivest"), [Adi Shamir](https://en.wikipedia.org/wiki/Adi_Shamir "Adi Shamir") and [Leonard Adleman](https://en.wikipedia.org/wiki/Leonard_Adleman "Leonard Adleman"), who publicly described the algorithm in 1977.
**RSA** is used for:

- Digital signatures  as [RSASSA-PSS](https://en.wikipedia.org/wiki/Probabilistic_signature_scheme) or [RSA_FDH](https://en.wikipedia.org/wiki/Full_Domain_Hash)
- [public-key-encryption](https://en.wikipedia.org/wiki/Public-key_cryptography) of small or short messages.

## How does it works?

**RSA** relies on a mathematical asymmetry:
Multiplying two large number is very easy, but **factoring** their product is computationally **hard**.
This allows anyone to publish a **public encryption key** while keeping a **private decryption key** secret.
The process involves three roles:

1. The **receiver** generates a public key (using private information known only to them).
2. The **sender** encrypts the message using the receiver’s public key.
3. The **receiver** decrypts the ciphertext using their private key.

### Key generation and algorithm

#### Receiver side (Key generation)

1. Pick two prime numbers **p** and **q**. These are kept **secret** (private)
2. Compute $n=pq$  
   $\Rightarrow n$ is part of the **public key**. (it's extremely hard to find $q$ and $p$ starting from $n$)  
3. Compute Euler's totient:
   $\phi(n)=(p-1)(q-1)$
4. Choose a public exponent $e$ such that $gcd(e,\phi(n))=1$
   A common choice is **65537**
5. compute  the **private key** **d**:  
   $d \times e \equiv 1 \pmod{\phi(n)} \Rightarrow d = e^{-1} \bmod{\phi(n)}$  
**Public key: $(n,e)$  
Private key:** $(n,d)$ (with $p$ and $q$ kept secret for key recovery and optimizations; they are not typically distributed)

#### Sender side (encryption)

1. Represent the message $m$ as a number smaller than $n$ (via ASCII or padded encoding)
2. Using the receiver's public key $(n,e)$ compute:
   $c = m^e\mod(n)$
3. Send the ciphertext $c$

#### Receiver side (decryption)

1. Receive $c$.
2. Use the private key $d$ to recover the plaintext:
   $m=c^d\mod(n)$

### Notes on Security and practice

- The security of RSA depends on the difficulty of factoring large numbers $n=p\times q$. For 2048-bit $n$ this is currently **infeasible**
  >why?
  A 2048 bit number is about:
  $2^{2048} \approx 10^{617}$ That's a **617 digits number.**
  You'd need to **find** *two primes* that multiply to it.
  Those number are so large that even modern supercomputers can't brute-force them or factor them.
  The most efficient, general purpose algorithm today is the **General Number Field Sieve (GNFS)**. It's time complexity grows *sub-exponentially*, but it's still extremely steep:
  expected complexity time: $O\Big(e^{\sqrt[3]{\frac{64}{9}}(\log N)^{1/3}(\log\log N)^{2/3}}\Big)$  
  To give a perspective:  
  To brute force a 512 bits key it would take a few hourse on a PC  
  To brute force a 768 bits key it would take Months on hundreds of computers  
  To brute force a 1024 buts it would take **thousands of years** with current tech  
  To brute force a 2048 bits it would take **billions of years** with all world computers combined.
- In **real applications** RSA is **not used directly on raw text**
  Messages are padded with secure schemes like **OAEP** before encryption to prevent attacks.
- RSA can also be used in the **opposite direction** (encrypt with private key, decrypt with public key) to create **digital signatures**.

## Encoding a text trough RSA
In this section we implement a simple, educational experiment:  
we will encrypt a plaintext message using RSA **character-by-character** and try to recover the original text using statistical techniques (reference distributions) and a lookup attack.  
The goal is not to build a secure system but to illustrate why naive uses of RSA are insecure and how classical cryptanalysis techniques behave when applied to public-key ciphertext.  
Why per-character RSA? When you encrypt each ASCII character independently with the same public key, the encryption acts like a deterministic substitution on the small plaintext alphabet (0–255). That means the ciphertext preserves plaintext frequency structure:   high-frequency plaintext symbols (like space or “e”) will correspond to high-frequency ciphertext symbols. This makes the instance suitable for two pedagogical attacks:  

**a reference-distribution (frequency) attack**, where we match ciphertext symbol frequencies to English letter frequencies and try to infer a substitution mapping, and

**a lookup-table (brute-force) attack**, where an attacker precomputes $c=m^e\mod(n)$ for every possible byte $m$ and inverts the mapping directly
<!-- BRUTE FORCE ATTACK VEDERE SE HO TEMPO DI IMPLEMENTARLO, NON è RICHIESTO.. -->
<section class="RSA-container" id="cc-ui">
  <h3>RSA encoding</h3>

  <label for="cc_input">Text to encrypt/decrypt</label>
  <textarea id="cc_input" rows="6" placeholder="Type or paste your text…"></textarea>
  <label>Prime p:</label>
<input id="prime_p" value="61">

<label>Prime q:</label>
<input id="prime_q" value="53">

<button id="generate_keys">Generate Keys</button>

  <div class="row" style="margin-top:.5rem;">
    <button id="cc_encrypt">Encrypt</button>
  </div>

  <label for="cc_output" style="margin-top:.6rem;">Result</label>
  <textarea id="cc_output" rows="6" readonly placeholder="The result will appear here…"></textarea>

  <div class="row" style="margin-top:.5rem;">
    <button id="cc_autodecode">Decode by frequency</button>
    <!-- <button id="cc_copy" class="secondary">Copy result</button>
    <button id="cc_download" class="secondary">Download .txt</button>  --> 
    <!-- NON LINKATI.. forse li aggiungo successivamente. -->
     <!-- Key + math details -->
<section id="rsa_details" style="margin-top:1rem;">
  <h4>Key details</h4>
  <div id="rsa_keyvals">
    <!-- filled by JS: p, q, n, phi, e, d -->
  </div>

  <h4 style="margin-top:.8rem;">Per-character encoding (first 50 chars)</h4>
  <div class="table-wrap" style="overflow:auto; max-height:240px; border:1px solid #ddd;">
    <table id="rsa_char_table" style="width:100%; border-collapse:collapse; font-size:.9rem;">
      <thead>
        <tr>
          <th style="text-align:center; padding:.3rem; border-bottom:1px solid #ddd;">Index</th>
          <th style="text-align:center; padding:.3rem; border-bottom:1px solid #ddd;">Char</th>
          <th style="text-align:center; padding:.3rem; border-bottom:1px solid #ddd;">ASCII</th>
          <th style="text-align:center; padding:.3rem; border-bottom:1px solid #ddd;">c = m^e mod n</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <p id="rsa_notes" style="margin-top:.6rem; color:#555;"></p>
</section>
  </div>

  <script src="{{ '/assets/js/hw2.js' | relative_url }}" defer></script>
  <script src="{{ '/assets/js/hw3.js' | relative_url }}" defer></script>

  