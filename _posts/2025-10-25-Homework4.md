---
title: Homework4
date: 2025-10-25 00:10:00 
categories: [TOP_CATEGORY, SUB_CATEGORY]
tags: [homework]     # TAG names should always be lowercase
css: /assets/css/prova.css
math: true
---
<link rel="stylesheet" href="{{ '/assets/css/prova.css'}}">
<link rel="stylesheet" href="{{ '/assets/css/hw4.css'}}">

# Converge to probability

This concept applies to a sequence of **random variables,** $X_N$  not fixed numbers.  A random variable doesn't have a single value, but rather a probability distribution of possibile outcomes.
A sequence of random variables $X_n$ converges in probability to a limit $X$ if, for any small distance $\epsilon > 0$
$\lim_{n\to\infty} P(|X_n - X| > \epsilon) = 0$  
Let's break this down:  
**$(|X_n - X|)$** is the distance between the random variable and its limit.  
**$P(|X_n - X| > \epsilon)$** is the **probability** that this distance is large (i.e., the probability that $X_n$ falls _outside_ the "intorno" around $X$).  
The definition says this **probability** must go to 0 as $n$ gets infinitely large.10
The key idea is that doesn't mean $X_n$ is guaranteed to be close to $X$. It means the chance of $X_n$ being ''far away'' become **really** small. For any large $n$, a "fluke" outcome is still possibile but it becomes increasingly unlikely.

## Simple analogy: Flipping a coin

This is the most common example, known ad the **Weak Law of Large Numbers**

- Let $X_n$ be the **average number of heads** after you flip a fair coin $n$ times.
- The limit $X$ is the "true" probability, which is **0.5**.
As you flip the coin more and more (as $n$ increases), you expect your average $X_n$ to get closer to 0.5.
- **$n = 10$ flips:** It's quite possible to get 7 heads (an average of 0.7), or 3 heads (an average of 0.3). The probability of being far from 0.5 is still significant.
- **$n = 1000$ flips:** It is _extremely_ unlikely you'll get 700 heads (average of 0.7). It's not _impossible_, but the probability is tiny. Most results will be very close to 500 heads (average $\approx 0.5$).
- **$n = 1,000,000$ flips:** The probability of getting an average of 0.7 is practically zero.
This is "convergence in probability." We are not saying it's _impossible_ to get an average of 0.7 with a million flips. We are saying the **probability** of that "unusual" event happening gets smaller and smaller, approaching 0 as $n$ increases.

<html>
<head>
<title>Bernoulli Trials Demo</title>
</head>
<body>
    <div class="wrap">
        <h1>Convergence in Probability: Bernoulli Trials Demo</h1>
        <div class="sub">Simulate <em>n</em> Bernoulli trials with success probability <em>p</em> and watch the running frequency \(\bar X_n\) converge to <em>p</em>.</div>

        <!-- pannello di controllo -->
        <div class = "panel">
            <div class="controls">
                <div class="single-control">
                    <label>Success probability (p): </label>
                    <div class = "row"><input id="p" type="range" min="0" max="1" step="0.01" value="0.5" style="accent-color: #219827;" oninput="ui.updateFromSlider()"></div>
                    <div class = "row"><input id="pText" type="number" min = "0" max = "1" step = "0.01" value="0.5" oninput="ui.updateFromText()"></div>
                </div>
                <div class="single-control">
                    <label>Number of trials (n): </label>
                    <div class = "row"><input id="n" type="number" min="1" max="1000000" step="1" value="1000"></div>
                </div>
                <div class="single-control">
                    <label>Batch size (steps per frame): </label>
                    <input id="batch" type="number" min ="1" step="1" value = "200" />
                </div>
                <div class ="single-control">
                    <label>Show 95% band</label>
                    <div class="row" style="gap:12px">
                        <input id="ci" type="checkbox" checked/>
                        <span class="note">±1.96·√(p(1−p)/n)</span>
                    </div>
                </div>
                <div class="single-control">
                    <div class="buttons">
                        <button id="startStop" class="primary">Start</button>
                        <button id="reset" class="danger">Reset</button>
                    </div>
                </div>
            </div>
            <div class="board">
                <h3>Running Frequency \(\bar X_n = S_n/n\) vs. true p</h3>
                <div class="canvas-wrap"><canvas id="freq"></canvas></div>
                <div class="legend">
                    <span class="key"><span class="swatch"></span>\(\bar X_n\)</span>
                    <span class="key"><span class="swatch green"></span>True p</span>
                    <span class="key"><span class="swatch red"></span>95% Confidence Band</span>
                </div>
                <div class="stats">
                    <div class="stat"><strong id="statN">n = 0</strong><span>Trials so far</span></div>
                    <div class="stat"><strong id="statMean">\(\bar X_n\) = 0.000</strong><span>Running frequency</span></div>
                    <div class="stat"><strong id="statErr">|error| = 0.000</strong><span>Absolute error vs p</span></div>
                </div>
            </div>
        </div>
        </div>
    <script>


  const ui = {
    updateFromSlider() { const p = parseFloat(document.getElementById('p').value); document.getElementById('pText').value = p.toFixed(2); state.p = p; drawAll(); },
    updateFromText()   { let v = parseFloat(document.getElementById('pText').value); if (isNaN(v)) v = 0.5; v = Math.max(0, Math.min(1, v)); document.getElementById('pText').value = v.toFixed(2); document.getElementById('p').value = v; state.p = v; drawAll(); },
  };

  window.ui = ui; // expose for console debugging

  const state = {
    p: 0.5,
    N: 5000,
    batch: 200,
    showCI: true,
    n: 0,
    s: 0,
    freqSeries: [], // y = S_n/n for n >= 1 (store sparse samples for drawing)
    outcomes: [],   // 0/1 outcomes (capped for drawing)
    rng: Math.random,
    running: false,
    raf: null,
  };
    function getRNG() {
        return Math.random;
    }

    window.state = state; // expose for console debugging


  //--- canvas ----
    function makeCtx(id) {
      const canvas = document.getElementById(id);
      const ctx = canvas.getContext('2d');
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width  = Math.max(600, Math.floor(rect.width  * dpr));
        canvas.height = Math.max(200, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // store CSS pixel sizes
        wrapper.w = rect.width;
        wrapper.h = rect.height;
      }
      const wrapper = { canvas, ctx, w: 0, h: 0, resize };
      resize();
      window.addEventListener('resize', resize);
      return wrapper;
    }

    const freqCtx = makeCtx('freq');

    // ------- Helpers -------
    function clear(ctx, w, h) { ctx.clearRect(0, 0, w, h); }
    function grid(ctx, w, h) {
      ctx.save();
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      for (let x = 40; x < w; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
      for (let y = 0; y < h; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
      ctx.restore();
    }

    // ------- Drawing -------
    function drawFreq() {
      const { ctx, w, h } = freqCtx;
      clear(ctx, w, h); grid(ctx, w, h);

      const padL = 40, padR = 10, padT = 14, padB = 28;
      const plotW = w - padL - padR;
      const plotH = h - padT - padB;

      // axes
      ctx.save();
      ctx.strokeStyle = '#4762a8';
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, padT + plotH); ctx.lineTo(padL + plotW, padT + plotH); ctx.stroke();
      ctx.fillStyle = '#666';
      ctx.font = '12px system-ui';
      ctx.fillText('0', padL - 16, padT + plotH + 14);

      const N = Math.max(1, state.N);
      const xScale = (n) => padL + (n / N) * plotW;
      const yScale = (y) => padT + (1 - y) * plotH;

      // true p line
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-2') || '#7cf1b4';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6, 6]);
      ctx.beginPath(); ctx.moveTo(padL, yScale(state.p)); ctx.lineTo(padL + plotW, yScale(state.p)); ctx.stroke();
      ctx.setLineDash([]);

      // 95% band
      if (state.showCI && state.n > 1) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 107, 107, 0.15)';
        ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i <= state.n; i++) {
          const se = Math.sqrt(state.p * (1 - state.p) / i);
          const lower = Math.max(0, state.p - 1.96 * se);
          const x = xScale(i);
          if (i === 1) ctx.moveTo(x, yScale(lower)); else ctx.lineTo(x, yScale(lower));
        }
        for (let i = state.n; i >= 1; i--) {
          const se = Math.sqrt(state.p * (1 - state.p) / i);
          const upper = Math.min(1, state.p + 1.96 * se);
          const x = xScale(i);
          ctx.lineTo(x, yScale(upper));
        }
        ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
      }

      // running frequency
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#4ea3ff';
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      const maxIdx = Math.min(state.freqSeries.length, state.n);
      for (let i = 0; i < maxIdx; i++) {
        const n = i + 1;
        const x = xScale(n);
        const y = yScale(state.freqSeries[i]);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // labels
      ctx.fillStyle = '#222';
      ctx.fillText('trials n →', padL + plotW - 70, padT + plotH + 18);
      ctx.save(); ctx.translate(10, padT + plotH/2); ctx.rotate(-Math.PI/2);
      ctx.fillText('frequency of success', 0, 0); ctx.restore();
    }

    

    function drawAll() {
      drawFreq();
      const mean = state.n ? state.s / state.n : 0;
      document.getElementById('statN').textContent = `n = ${state.n.toLocaleString()}`;
      document.getElementById('statMean').textContent = `\u0305X_n = ${mean.toFixed(3)}`;
      document.getElementById('statErr').textContent = `|error| = ${Math.abs(mean - state.p).toFixed(3)}`;
    }

    // ------- Simulation -------
    function stepOnce() {
      if (state.n >= state.N) return false;
      const u = state.rng();
      const x = (u < state.p) ? 1 : 0;
      state.n += 1; state.s += x;
      state.outcomes.push(x);
      state.freqSeries.push(state.s / state.n);
      return true;
    }

    function stepBatch(k) {
      let count = 0;
      for (let i = 0; i < k && state.n < state.N; i++) { stepOnce(); count++; }
      return count;
    }

    function loop() {
      if (!state.running) return;
      stepBatch(state.batch);
      drawAll();
      if (state.n >= state.N) { state.running = false; updateStartStopLabel(); return; }
      state.raf = requestAnimationFrame(loop);
    }

    function updateStartStopLabel() {
      const btn = document.getElementById('startStop');
      btn.textContent = state.running ? 'Stop' : 'Start';
    }

    function reset() {
      state.p = parseFloat(document.getElementById('p').value);
      state.N = parseInt(document.getElementById('n').value, 10) || 1000;
      state.batch = parseInt(document.getElementById('batch').value, 10) || 100;
      state.showCI = document.getElementById('ci').checked;

      state.n = 0; state.s = 0;
      state.freqSeries = []; state.outcomes = [];
      state.rng = getRNG();

      state.running = false;
      cancelAnimationFrame(state.raf);
      updateStartStopLabel();
      drawAll();
    }

    // ------- Events -------
    document.getElementById('startStop').addEventListener('click', () => {
      state.running = !state.running;
      updateStartStopLabel();
      if (state.running) loop();
    });

    document.getElementById('reset').addEventListener('click', reset);

    document.getElementById('n').addEventListener('change', () => {
      state.N = parseInt(document.getElementById('n').value, 10) || state.N;
    });

    document.getElementById('batch').addEventListener('change', () => {
      state.batch = parseInt(document.getElementById('batch').value, 10) || state.batch;
    });

    document.getElementById('ci').addEventListener('change', () => {
      state.showCI = document.getElementById('ci').checked; drawAll();
    });

    window.addEventListener('resize', drawAll);

    // ------- Boot -------
    reset();
    </script>

  </body>
</html>

