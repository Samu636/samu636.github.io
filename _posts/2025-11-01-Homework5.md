---
title: Homework5
date: 2025-11-01 00:10:00 
categories: [TOP_CATEGORY, SUB_CATEGORY]
tags: [homework]     # TAG names should always be lowercase
css: /assets/css/prova.css
math: true
---

# Measure of Location (averages)

A measure of location, or average, is a single value that represents the center of a dataset's typical values. Different types of averages are useful depending on the nature of the data and the presence of outliers.

## Arithmetic Mean

The arithmetic mean is the most common type of average.
$\overline{x} = {x_1+x_2+ ... +x_n}/n$
It makes sense when all observation are of similar scale and there are **no** **extreme values**

## Median

The median is the middle value when **all observation are ordered**.
It is not effected by extreme values or outliers.

## Mode

The mode is the most frequent value in a dataset.  
It is mainly used for categorical or discrete data.  

## Geometric mean

The geometric mean is used when data values are multiplied together or represent growth rates.
$GM = \sqrt[n]{x_1+x_2+ ... +x_n}$
It makes sense when value are positive and vary proportionally.

## Harmonic Mean

The harmonic mean is useful when averaging rates or ratios.
$HM=\frac{n}{(\frac{1}{x_1}+)(\frac{1}{x_2}+...)(\frac{1}{x_n})}$

<style>
  :root {
    color-scheme: light dark;
  }

  body {
    font-family: system-ui, sans-serif;
    max-width: 800px;
    margin: 30px auto;
    padding: 0 20px;
    line-height: 1.6;
  }

  h1, h2 {
    text-align: center;
  }

  .box {
    border: 1px solid #8883;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 40px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    background-color: color-mix(in srgb, Canvas 95%, CanvasText 5%);
  }

  input[type="number"] {
    width: 180px;
    padding: 6px 8px;
    margin-right: 10px;
    border-radius: 6px;
    border: 1px solid #8886;
    background-color: inherit;
    color: inherit;
  }

  button {
    padding: 6px 12px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    background-color: #0078d4;
    color: white;
  }

  button:hover {
    background-color: #005fa3;
  }

  .result {
    margin-top: 8px;
    font-weight: bold;
  }

  canvas {
    width: 100% !important;
    max-height: 300px;
  }

  p {
    margin: 5px 0;
  }

  #classic-list {
    font-family: monospace;
  }
</style>
  <title>Mean & Variance</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; max-width: 9000px; margin: 20px auto; }
    h2 { margin-top: 40px; }
    .box { border: 1px solid #ddd; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    label, input, button { font-size: 1rem; }
    .result { margin-top: 10px; font-weight: bold; }
  </style>
<body>

  <h1>Mean & Variance Homework</h1>

  <!-- 1) CLASSICAL METHOD -->
  <div class="box">
    <h2>1. Classical calculation</h2>
    <p>Insert numbers one by one, then click "Finish".</p>
    <input type="number" id="classic-input" placeholder="Enter a number" />
    <button id="classic-add">Add</button>
    <button id="classic-finish">Finish</button>
    <p>Numbers: <span id="classic-list">[]</span></p>
    <p class="result">Mean: <span id="classic-mean">-</span></p>
    <p class="result">Variance: <span id="classic-variance">-</span></p>
  </div>

  <!-- 2) ONLINE METHOD -->
  <div class="box">
    <h2>2. Online (incremental) calculation</h2>
    <p>Every time you add a number, mean and variance are updated.</p>
    <input type="number" id="online-input" placeholder="Enter a number" />
    <button id="online-add">Add</button>
    <p class="result">Count: <span id="online-count">0</span></p>
    <p class="result">Mean: <span id="online-mean">-</span></p>
    <p class="result">Variance: <span id="online-variance">-</span></p>

    <h3>Online evolution</h3>
    <canvas id="online-chart" width="400" height="200"></canvas>
  </div>

  <!-- <script>
    /* ================================
       1) CLASSICAL CALCULATION
       ================================ */
    const classicNumbers = [];
    const classicInput = document.getElementById('classic-input');
    const classicList = document.getElementById('classic-list');
    const classicMeanSpan = document.getElementById('classic-mean');
    const classicVarSpan = document.getElementById('classic-variance');

    document.getElementById('classic-add').addEventListener('click', () => {
      const val = parseFloat(classicInput.value);
      if (!isNaN(val)) {
        classicNumbers.push(val);
        classicList.textContent = JSON.stringify(classicNumbers);
        classicInput.value = '';
        classicInput.focus();
      }
    });
    classicInput.addEventListener("keydown", (event) => {
  if (event.key === "Enter") {
    event.preventDefault(); // prevent form submission
    document.getElementById("classic-add").click();
  }
});

    document.getElementById('classic-finish').addEventListener('click', () => {
      if (classicNumbers.length === 0) return;

      const n = classicNumbers.length;
      const sum = classicNumbers.reduce((a, b) => a + b, 0);
      const mean = sum / n;
      const variance = n > 1
        ? classicNumbers.reduce((acc, x) => acc + Math.pow(x - mean, 2), 0) / (n - 1)
        : 0;

      classicMeanSpan.textContent = mean.toFixed(3);
      classicVarSpan.textContent = variance.toFixed(3);
    });

    /* ================================
       1) ONLINE / INCREMENTAL METHOD
       (Welford's algorithm)
       ================================ */
    let n = 0;
    let mean = 0;
    let M2 = 0;

    const onlineInput = document.getElementById('online-input');
    const onlineCountSpan = document.getElementById('online-count');
    const onlineMeanSpan = document.getElementById('online-mean');
    const onlineVarSpan = document.getElementById('online-variance');

    // chart setup
    const ctx = document.getElementById('online-chart').getContext('2d');
    const onlineChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],           // will be 1,2,3,4...
        datasets: [
          {
            label: 'Mean',
            data: [],
            borderWidth: 2
          },
          {
            label: 'Variance',
            data: [],
            borderWidth: 2
          }
        ]
      },
      options: {
        responsive: true,
        scales: {
          y: { beginAtZero: true }
        }
      }
    });

    document.getElementById('online-add').addEventListener('click', () => {
      const x = parseFloat(onlineInput.value);
      if (isNaN(x)) return;

      // Welford update
      n += 1;
      const delta = x - mean;
      mean += delta / n;
      M2 += delta * (x - mean);

      const variance = n > 1 ? M2 / (n - 1) : 0;

      // update DOM
      onlineCountSpan.textContent = n;
      onlineMeanSpan.textContent = mean.toFixed(3);
      onlineVarSpan.textContent = variance.toFixed(3);

      // update chart
      onlineChart.data.labels.push(n.toString());
      onlineChart.data.datasets[0].data.push(mean);
      onlineChart.data.datasets[1].data.push(variance);
      onlineChart.update();

      onlineInput.value = '';
      onlineInput.focus();
    });
    onlineInput.addEventListener("keydown", (event) => {
  if (event.key === "Enter") {
    event.preventDefault();
    document.getElementById("online-add").click();
  }
});
  </script> -->
  <script defer src="{{ '/assets/js/hw5.js' | relative_url }}"></script>
</body>

# Advantages of the online algorithm:
**Memori efficiency**:
Online algorithms don't need to store all the previous data.
They only keep track of a few variables (like count, mean, and running total of squared differences).
This is ideal for:
- Real time data streams
- very large dataset that can't fit into memory.
**Speed performance**:
Each new data point requires only a few sumple arithmetic operations (additions and multiplactions).
There's no need to reprocess the entire datase, so **the complexity update is O(1)**
The classical method requires **O(n)**
**Real time update**
Online algorithms can provide update statistics as new data arrives, this is usefull in monitoring system.
# Limitations of the online algorithm:
**Harder to debug**:
Since past data points aren't stored, you can't easily check or recompute resoults.
**Error propagation**:
If there's a mistake early in the process, it can effect **all later computations!**
**Less flexible**:
Online algos are great for incremental update, nut not for changing or removing data points. If one past value needs to be corrected, you must restart the calculation.