---
title: Homework2
date: 2025-10-11 00:10:00 
categories: [TOP_CATEGORY, SUB_CATEGORY]
tags: [homework]     # TAG names should always be lowercase
css: /assets/css/prova.css
---
<link rel="stylesheet" href="{{ '/assets/css/prova.css'}}">

# Dataset & Distribution

## Dataset

A dataset is a collection of data, typically organized in **rows and columns**:

- Each **row** = one observation or **record** (one student, one car..)
- Each **columns** = one feature or **variable** (age, gender..)
- A table of students with their gender, age, and test score is a dataset.

### Key components of a Dataset

1. **Variables**
   The characteristics being measured:
   - *Quantitative*: Measurable values like height, score, or weight
   - *Qualitative*: Descriptive values like color or duty
2. **Records**
   Each data point (one full row of values)
3. **Data types**
   Each variable can have:
   - integer / float values
   - Text / string
   - Date / boolean
4. **Metadata**:
   Data about the data, for example columns names, data types, units of measurement..

## Distribution

A **distribution** show how values of a variable are spread across the possible outcomes.

- **Univariate distribution:** how one variable’s values are distributed.  
    Example: distribution of exam scores → how many students got 10–15, 15–20, etc.
- **Bivariate distribution:** how two variables vary together.  
    Example: relation between *gender* and *exam score* categories.

## Univariate and Bivariate Distribution on a dataset

Here is and example using a dataset created with sqlite

### Creating a new Table

First of all, we have to create a new table:

```sql
CREATE TABLE cyber_attacks (
  id INTEGER PRIMARY KEY,
  attack_type TEXT,
  severity_level TEXT,
  response_time INTEGER,
  date_detected TEXT,
  source_region TEXT,
  target_system TEXT,
  protocol TEXT,
  bytes_transferred INTEGER
);
```

### Populating our table

Now we have to insert some values into our newly created table:

```sql
INSERT INTO cyber_attacks (attack_type, severity_level, response_time, date_detected, source_region, target_system, protocol, bytes_transferred) VALUES

('DDoS','Medium',95,'2025-10-05','US','Gateway','UDP',900000),
('DDoS','High',125,'2025-10-04','EU','Web Server','UDP',1600000),
('DDoS','Medium',100,'2025-10-03','ASIA','Gateway','UDP',800000),
('Malware','Medium',76,'2025-09-28','EU','Web Server','HTTP',54000),
('Malware','Low',50,'2025-09-24','SA','Mail Server','SMTP',18000),
('Phishing','Medium',52,'2025-09-23','EU','Mail Server','SMTP',2300),
('Phishing','High',80,'2025-09-21','ASIA','Auth Server','HTTP',4800);
--... additional values omitted for brevity
```

### Univariate distribution of our dataset

A univariate distribution describes the probability distribution of a single random variable at the time.

#### Frequency of attacks

```sql
SELECT attack_type, count(*) AS frequency  
from cyber_attacks  
GROUP BY attack_type  
order by frequency desc;
```

##### Output

![FrequecyOfAttacks](/images/hw2/1frequency_of_attacks_output.png)
*Frequency of attacks*

#### Frequency of attacker by region

```sql
SELECT source_region, COUNT(*) AS frequency  
FROM cyber_attacks  
GROUP BY source_region  
ORDER BY frequency DESC;
```

##### Output

![img-description](/images/hw2/2attacker_by_region.png)
*Attacker by Region*

### Bivariate distribution

A bivariate distribution describes the probability of two random variables occurring at the same time, showing the relationship between them. It provides probabilities for each possible combination of values for the two variables and can be represented in a table, graph, or function.

#### Average of bites transferred by attack_type

```sql
SELECT attack_type, ROUND(avg(bytes_transferred),2) AS average_bytes  
FROM cyber_attacks  
GROUP BY attack_type  
ORDER BY average_bytes DESC;
```

##### Output

This shows which attacks tend to transfer more data, for instance, DDos attacks typically transfer much larger volume
![](/images/hw2/3bites_x_attack.png)
*Bites X attacks*
![](/images/hw2/4bites_x_attack_output.png)
*Bites X attacks Graph*

#### Attack type x severity

```sql
SELECT attack_type,  
    SUM(CASE WHEN severity_level='Low' THEN 1 ELSE 0 END) AS Low,  
       SUM(CASE WHEN severity_level='Medium' THEN 1 ELSE 0 END) AS Medium,  
       SUM(CASE WHEN severity_level='High' THEN 1 ELSE 0 END) AS High  
FROM cyber_attacks  
GROUP BY attack_type  
ORDER BY attack_type;
```

![](/images/hw2/5attack_type_x_sec.png)
![](/images/hw2/6attack_type_x_sec_output.png)

# Text analysis and Caesar Cipher

## Text Analysis

**Text analysis** is the process of examining, interpreting, and transforming unstructured text data to extract useful information and patterns.  
For this assignment, we focus on the **fundamentals of text manipulation and frequency analysis**, which are essential steps in both **data preprocessing** and **basic cryptography**.  
By analyzing a given text, we can understand how characters or words are distributed, a concept that becomes particularly relevant when dealing with **classical ciphers** like the **Caesar Cipher**, where letter frequency can help decrypt encoded messages.

<!-- letter frequency analyzer section-->

<div id="freq-app" class="freq-container">
  <h2>Letter Frequency Analyzer tool</h2>

  <section class="card">
    <p>Paste or type text below, then click <strong>Analyze</strong>.</p>
    <textarea id="lf_text" rows="8" placeholder="Paste or type your text here..."></textarea>
    <div class="row">
      <button id="lf_analyze">Analyze</button>
      <button id="lf_clear">Clear</button>
    </div>
    <div id="lf_summary" class="muted"></div>
  </section>

  <section class="card">
    <h3>Distribution (letters a–z)</h3>
    <canvas id="lf_chart" width="900" height="260" aria-label="Letter frequency chart"></canvas>
    <div id="lf_table_wrap"></div>
  </section>
</div>

<!-- <style>
  .freq-container { max-width: 1000px; margin: 1rem 0 3rem; }
  .freq-container .card { padding: 1rem; border: 1px solid var(--blockquote-border-color, #ddd); border-radius: 12px; margin: 1rem 0; }
  .freq-container .row { display:flex; gap:.5rem; flex-wrap:wrap; margin:.5rem 0; }
  .freq-container textarea { width:100%; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .freq-container .muted { color: var(--text-muted-color, #666); margin:.5rem 0; }
  .freq-container table { border-collapse: collapse; width: 100%; font-variant-numeric: tabular-nums; }
  .freq-container th, .freq-container td { border-bottom:1px solid #e6e6e6; padding:.4rem .5rem; text-align:right; }
  .freq-container th:first-child, .freq-container td:first-child { text-align:left; }
  #lf_chart { max-width: 100%; display: block; }
</style> -->

<!-- <script>
(function() {
   const alphabet = 'abcdefghijklmnopqrstuvwxyz';
   // Normalize text: lowercase, remove non-a-z characters
   function normalizeText(text) {
     return text.toLowerCase().replace(/[^a-z]/g, ''); // keep only a-z, remove everything else
   }

   // Analyze letter frequency, return counts and percentages
   function analyzerFrequency(text){
      const freq = {};
      for (const char of alphabet) freq[char] = 0; // initialize counts to 0
      const totalChars = text.length;
      for (let char of text) {
         if (char in freq) freq[char]++;
      }
      // convert counts to percentages
      for (const char in freq) {
         freq[char] = ((freq[char] / totalChars) * 100).toFixed(2); // percentage with 2 decimal places
      }
      return freq;
   }
   function addPercentageSign(x) {
      return (x*1).toFixed(2) + '%';
   }

   //function to render the frequency table
   function renderTable(frequency) {
      const table = document.createElement('table');
      table.innerHTML = `
         <thead>
            <tr><th>Letter</th><th>Frequency</th></tr>
         </thead>
         <tbody></tbody>
      `;
      for (const ch of alphabet) {
         const row = document.createElement('tr');
         row.innerHTML = `<td>${ch}</td><td>${addPercentageSign(frequency[ch])}</td>`;
         table.querySelector('tbody').appendChild(row);
      }
      return table;
   }

   //plotting the frequency chart
   function plotChart(frequency) {
      const canvas = document.getElementById('lf_chart');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height); // clear previous chart

      const barWidth = canvas.width / alphabet.length;
      const maxFreq = Math.max(...Object.values(frequency).map(x => parseFloat(x)));

      // Draw bars
      alphabet.split('').forEach((ch, i) => {
         const barHeight = (parseFloat(frequency[ch]) / maxFreq) * (canvas.height - 20);
         ctx.fillStyle = '#5CE65C';
         ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 2, barHeight);
         ctx.fillStyle = '#f2f2f2';
         ctx.font = '10px monospace';
         ctx.fillText(ch, i * barWidth + barWidth / 2 - 3, canvas.height - 5);
         ctx.fillText(addPercentageSign(frequency[ch]), i * barWidth + barWidth / 2 - 10, canvas.height - barHeight - 10);
      });
   }




   document.getElementById('lf_analyze').addEventListener('click', function() {
      const tablewrap = document.getElementById('lf_table_wrap');
      console.log('Analyze button clicked');
      const text = document.getElementById('lf_text').value;
      const normalized = normalizeText(text);
      console.log(normalized); 
      const frequency = analyzerFrequency(normalized);
      console.log(JSON.stringify(frequency, null, 2)); 
      tablewrap.innerHTML = '' //clear previous table
      tablewrap.appendChild(renderTable(frequency));
      plotChart(frequency);
   });
   document.getElementById('lf_clear').addEventListener('click', function() {
      document.getElementById('lf_text').value = '';
      document.getElementById('lf_table_wrap').innerHTML = '';
      const canvas = document.getElementById('lf_chart');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height); // clear chart
   });


})(); //the double parentheses at the end invoke the function immediately!!!! important!!! 

</script> -->

## Caesar Cipher
The **Caesar cipher** is a simple encryption technique where each letter in the plaintext is shifted a certain number of places down or up the alphabet. For example, with a shift of 3, 'A' becomes 'D', 'B' becomes 'E', and so on. This method is named after Julius Caesar, who reportedly used it to communicate securely.



<section class="cipher-container" id="cc-ui">
  <h3>Caesar Cipher</h3>

  <label for="cc_input">Text to encrypt/decrypt</label>
  <textarea id="cc_input" rows="6" placeholder="Type or paste your text…"></textarea>

  <div class="row" style="margin-top:.5rem;">
    <label for="cc_shift" style="margin:0;">Shift (0–25):</label>
    <input id="cc_shift" type="number" min="0" max="25" value="7" />
    <button id="cc_encrypt">Encrypt</button>
  </div>

  <label for="cc_output" style="margin-top:.6rem;">Result</label>
  <textarea id="cc_output" rows="6" readonly placeholder="The result will appear here…"></textarea>

  <div class="row" style="margin-top:.5rem;">
    <button id="cc_bruteforce" class="secondary">Brute force (show all 26)</button>
    <button id="cc_autodecode">Auto-decode (by frequency)</button>
    <!-- <button id="cc_copy" class="secondary">Copy result</button>
    <button id="cc_download" class="secondary">Download .txt</button>  --> 
    <!-- NON LINKATI.. forse li aggiungo successivamente. -->
  </div>

  <div id="cc_status" class="muted">Ready.</div>

  <details id="cc_list_wrap" style="margin-top:.5rem;">
    <summary>All 26 candidates</summary>
    <div id="cc_candidates"></div>
  </details>
</section>

<!-- <script>
(function() {
   const alphabet = 'abcdefghijklmnopqrstuvwxyz';
   const $ = (sel) => document.querySelector(sel);
   const ENG_FREQ = {
      e: 12.02, t: 9.06, a: 8.17, o: 7.51, i: 7.00, n: 6.75,
      s: 6.33, h: 6.09, r: 5.99, d: 4.25, l: 4.03, c: 2.78,
      u: 2.76, m: 2.41, w: 2.36, f: 2.23, g: 2.02, y: 1.97,
      p: 1.93, b: 1.49, v: 0.98, k: 0.77, j: 0.15, x: 0.15,
      q: 0.10, z: 0.07
   };
   //shift char function based on shift selected
   function shiftChar(char, shift){
      const lowerCase = char.toLowerCase();
      const index = alphabet.indexOf(lowerCase);
      if (index === -1) return char; // non az non vengono convertiti
      const shiftedIndex = (index + shift + 26) % 26; 
      const shiftedChar = alphabet[shiftedIndex];
      return char === lowerCase ? shiftedChar : shiftedChar.toUpperCase();
    }

    function caesarCipher(text, shift) {
      return text.split('').map(char => shiftChar(char, shift)).join('');
    }
    //console.log(caesarCipher('Hello, World!', 3)); // "Khoor, Zruog!"

    //brute force all 26 shifts
      function bruteForce(text) {
         const res = [];
         for (let s = 0; s < 26; s++){
            res.push({shift: s, text: caesarCipher(text, -s) });
         }
         return res
      }

      //decrypt with frequency analysis


    document.addEventListener('DOMContentLoaded', function() {
      const input = document.getElementById('cc_input');
      const output = document.getElementById('cc_output');
      const shiftInput = document.getElementById('cc_shift');
      const status = document.getElementById('cc_status');
      const candidatesWrap = $('#cc_candidates');
      const listWrap = $('#cc_list_wrap');

      $('#cc_bruteforce').addEventListener('click', () => {
      const enc = input.value || '';
      const results = bruteForce(enc);
      candidatesWrap.innerHTML = '';
      results.forEach(r => {
        const card = document.createElement('div');
        card.className = 'card';
        card.style.marginBottom = '.5rem';
        card.innerHTML = `
          <div class="row" style="align-items:center;">
            <strong>shift ${r.shift}</strong>
            <button data-shift="${r.shift}" class="cc-use">Use</button>
            <button data-shift="${r.shift}" class="cc-copy">Copy</button>
            <button data-shift="${r.shift}" class="cc-dl">Download</button>
          </div>
          <textarea rows="3" readonly>${r.text}</textarea>
        `;
        candidatesWrap.appendChild(card);
      });
      listWrap.open = true;
     
      // delegate buttons
      candidatesWrap.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        const idx = parseInt(btn.dataset.shift, 10);
        const text = results.find(x => x.shift === idx)?.text || '';
        if (btn.classList.contains('cc-use')) { output.value = text; ok(`Loaded candidate with shift ${idx}.`); }
        if (btn.classList.contains('cc-copy')) { copyToClipboard(text); ok(`Copied candidate shift ${idx}.`); }
        if (btn.classList.contains('cc-dl')) { downloadText(text, `dec_shift_${idx}.txt`); }
      }, { once: true }); // attach once per generation
    });


    });
   })();
</script> -->
<script src="{{ '/assets/js/hw2.js' | relative_url }}" defer></script>